package tp67

// You should paste all your Scala code generated by Isabelle here
// and connect the Analyser.safe function to your analyser

// You can replace the code below


// Code generated by Isabelle


import utilities.Datatype._
// automatic conversion of utilities.Datatype.Int.int to Int.int
object AutomaticConversion {
  implicit def int2int(i: utilities.Datatype.Int.int): Int.int =
    i match {
      case utilities.Datatype.Int.int_of_integer(i) => Int.int_of_integer(i)
    }

  def bit_cut_integer(k: BigInt): (BigInt, Boolean) =
    (if (k == BigInt(0)) (BigInt(0), false)
     else {
       val (r, s): (BigInt, BigInt) =
         (
             (k: BigInt) =>
               (l: BigInt) =>
                 if (l == 0) (BigInt(0), k)
                 else
                   (k.abs /% l.abs)
         ).apply(k).apply(BigInt(2));
       ((if (BigInt(0) < k) r else (-r) - s), s == BigInt(1))
     })

  def char_of_integer(k: BigInt): Str.char = {
    val (q0, b0): (BigInt, Boolean) = bit_cut_integer(k)
    val (q1, b1): (BigInt, Boolean) = bit_cut_integer(q0)
    val (q2, b2): (BigInt, Boolean) = bit_cut_integer(q1)
    val (q3, b3): (BigInt, Boolean) = bit_cut_integer(q2)
    val (q4, b4): (BigInt, Boolean) = bit_cut_integer(q3)
    val (q5, b5): (BigInt, Boolean) = bit_cut_integer(q4)
    val (q6, b6): (BigInt, Boolean) = bit_cut_integer(q5)
    val a: (BigInt, Boolean) = bit_cut_integer(q6)
    val (_, aa): (BigInt, Boolean) = a;
    Str.Char(b0, b1, b2, b3, b4, b5, b6, aa)
  }

  def map[A, B](f: A => B, x1: List[A]): List[B] = (f, x1) match {
    case (f, Nil)     => Nil
    case (f, x :: xs) => f(x) :: map[A, B](f, xs)
  }

  def explodeList(l: List[Char]): List[Str.char] = {
    (l.map(c => {
      val k: Int = c.toInt;
      if (k < 128) BigInt(k) else sys.error("Non-ASCII character in literal")
    }))
      .map(a => char_of_integer(a))
  }

  def explode(s: String): List[Str.char] = {
    explodeList(s.toCharArray.toList)
  }

  // conversion from Scala String to HOL string
  implicit def string2charList(s: String): List[Str.char] = explode(s)

  // conversion from Scala List[Char] to HOL List[Str.char]
  implicit def charList2charList(l: List[Char]): List[Str.char] =
    explodeList(l)
  // conversion of a pair with a Scala List[String] on the first position
  // to an HOL pair with an HOL List[Str.char] on first position
  implicit def tupleString2tupleString[T](
      t: (List[Char], T)
  ): (List[Str.char], T) = t match {
    case (e1, e2) => (charList2charList(e1), e2)
  }

  // conversion from Isabelle Int.int to Project Int.int
  implicit def int2dataint(i: Int.int): utilities.Datatype.Int.int =
    i match {
      case Int.int_of_integer(i) => utilities.Datatype.Int.int_of_integer(i)
    }

  def stringChar2char(x: Str.char): Char = {
    x match {
      case Str.Char(x1, x2, x3, x4, x5, x6, x7, x8) => {
        var n = 0;
        n = if (x8) 2 * n + 1 else 2 * n;
        n = if (x7) 2 * n + 1 else 2 * n;
        n = if (x6) 2 * n + 1 else 2 * n;
        n = if (x5) 2 * n + 1 else 2 * n;
        n = if (x4) 2 * n + 1 else 2 * n;
        n = if (x3) 2 * n + 1 else 2 * n;
        n = if (x2) 2 * n + 1 else 2 * n;
        n = if (x1) 2 * n + 1 else 2 * n;
        n.toChar
      }
    }
  }

  // conversion from Isabelle String to Lists of Chars
  implicit def charList2String(l: List[Str.char]): List[Char] = {
    l.map(stringChar2char(_))
  }
}

import AutomaticConversion._


object HOL {

trait equal[A] {
  val `HOL.equal`: (A, A) => Boolean
}
def equal[A](a: A, b: A)(implicit A: equal[A]): Boolean = A.`HOL.equal`(a, b)
object equal {
  implicit def `Str.equal_char`: equal[Str.char] = new equal[Str.char] {
    val `HOL.equal` = (a: Str.char, b: Str.char) => Str.equal_chara(a, b)
  }
  implicit def `Lista.equal_list`[A : equal]: equal[List[A]] = new
    equal[List[A]] {
    val `HOL.equal` = (a: List[A], b: List[A]) => Lista.equal_lista[A](a, b)
  }
}

def eq[A : equal](a: A, b: A): Boolean = equal[A](a, b)

} /* object HOL */

object Num {

abstract sealed class num
final case class One() extends num
final case class Bit0(a: num) extends num
final case class Bit1(a: num) extends num

} /* object Num */

object Code_Numeral {

def integer_of_int(x0: Int.int): BigInt = x0 match {
  case Int.int_of_integer(k) => k
}

} /* object Code_Numeral */

object Int {

abstract sealed class int
final case class int_of_integer(a: BigInt) extends int

def one_int: int = int_of_integer(BigInt(1))

def plus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) +
                   Code_Numeral.integer_of_int(l))

def zero_int: int = int_of_integer(BigInt(0))

def equal_int(k: int, l: int): Boolean =
  Code_Numeral.integer_of_int(k) == Code_Numeral.integer_of_int(l)

def minus_int(k: int, l: int): int =
  int_of_integer(Code_Numeral.integer_of_int(k) -
                   Code_Numeral.integer_of_int(l))

def uminus_int(k: int): int =
  int_of_integer((- (Code_Numeral.integer_of_int(k))))

} /* object Int */

object Nat {

abstract sealed class nat
final case class zero_nat() extends nat
final case class Suc(a: nat) extends nat

def minus_nat(m: nat, n: nat): nat = (m, n) match {
  case (Suc(m), Suc(n)) => minus_nat(m, n)
  case (zero_nat(), n) => zero_nat()
  case (m, zero_nat()) => m
}

} /* object Nat */

object Product_Type {

def equal_bool(p: Boolean, pa: Boolean): Boolean = (p, pa) match {
  case (p, true) => p
  case (p, false) => ! p
  case (true, p) => p
  case (false, p) => ! p
}

} /* object Product_Type */

object Str {

abstract sealed class char
final case class Char(a: Boolean, b: Boolean, c: Boolean, d: Boolean,
                       e: Boolean, f: Boolean, g: Boolean, h: Boolean)
  extends char

def equal_chara(x0: char, x1: char): Boolean = (x0, x1) match {
  case (Char(x1, x2, x3, x4, x5, x6, x7, x8),
         Char(y1, y2, y3, y4, y5, y6, y7, y8))
    => Product_Type.equal_bool(x1, y1) &&
         (Product_Type.equal_bool(x2, y2) &&
           (Product_Type.equal_bool(x3, y3) &&
             (Product_Type.equal_bool(x4, y4) &&
               (Product_Type.equal_bool(x5, y5) &&
                 (Product_Type.equal_bool(x6, y6) &&
                   (Product_Type.equal_bool(x7, y7) &&
                     Product_Type.equal_bool(x8, y8)))))))
}

} /* object Str */

object Lista {

def equal_lista[A : HOL.equal](x0: List[A], x1: List[A]): Boolean = (x0, x1)
  match {
  case (Nil, x21 :: x22) => false
  case (x21 :: x22, Nil) => false
  case (x21 :: x22, y21 :: y22) =>
    HOL.eq[A](x21, y21) && equal_lista[A](x22, y22)
  case (Nil, Nil) => true
}

def take[A](n: Nat.nat, x1: List[A]): List[A] = (n, x1) match {
  case (n, Nil) => Nil
  case (n, x :: xs) => (n match {
                          case Nat.zero_nat() => Nil
                          case Nat.Suc(m) => x :: take[A](m, xs)
                        })
}

def gen_length[A](n: Nat.nat, x1: List[A]): Nat.nat = (n, x1) match {
  case (n, x :: xs) => gen_length[A](Nat.Suc(n), xs)
  case (n, Nil) => n
}

def size_list[A]: (List[A]) => Nat.nat =
  ((a: List[A]) => gen_length[A](Nat.zero_nat(), a))

} /* object Lista */

object tp67 {

  abstract sealed class option[A]
  final case class Nonea[A]() extends option[A]
  final case class Somea[A](a: A) extends option[A]
  
  abstract sealed class staticValue
  final case class Undefine() extends staticValue
  final case class Value(a: Int.int) extends staticValue
  final case class Either(a: Int.int, b: Int.int) extends staticValue
  
  abstract sealed class staticEvent
  final case class SX(a: staticValue) extends staticEvent
  final case class SP(a: staticValue) extends staticEvent
  
  def staticSub(x0: staticValue, uu: staticValue): staticValue = (x0, uu) match {
    case (Undefine(), uu) => Undefine()
    case (Value(v), Undefine()) => Undefine()
    case (Either(v, va), Undefine()) => Undefine()
    case (Value(x), Value(y)) => Value(Int.minus_int(x, y))
    case (Either(x, y), Value(z)) =>
      Either(Int.minus_int(x, z), Int.minus_int(y, z))
    case (Value(x), Either(y, z)) =>
      Either(Int.minus_int(x, y), Int.minus_int(x, z))
    case (Either(x, y), Either(z, t)) => Undefine()
  }
  
  def staticAdd(x0: staticValue, uu: staticValue): staticValue = (x0, uu) match {
    case (Undefine(), uu) => Undefine()
    case (Value(v), Undefine()) => Undefine()
    case (Either(v, va), Undefine()) => Undefine()
    case (Value(x), Value(y)) => Value(Int.plus_int(x, y))
    case (Either(x, y), Value(z)) =>
      Either(Int.plus_int(x, z), Int.plus_int(y, z))
    case (Value(x), Either(y, z)) =>
      Either(Int.plus_int(x, y), Int.plus_int(x, z))
    case (Either(x, y), Either(z, t)) => Undefine()
  }
  
  def assoc[A : HOL.equal, B](uu: A, x1: List[(A, B)]): option[B] = (uu, x1) match
    {
    case (uu, Nil) => Nonea[B]()
    case (x1, (x, y) :: xs) =>
      (if (HOL.eq[A](x, x1)) Somea[B](y) else assoc[A, B](x1, xs))
  }
  
  def staticEvalE(x0: expression, e: List[(List[Str.char], staticValue)]):
        staticValue
    =
    (x0, e) match {
    case (Constant(s), e) => Value(s)
    case (Variable(s), e) =>
      (assoc[List[Str.char], staticValue](s, e) match {
         case Nonea() => Value(Int.uminus_int(Int.one_int))
         case Somea(y) => y
       })
    case (Sum(e1, e2), e) => staticAdd(staticEvalE(e1, e), staticEvalE(e2, e))
    case (Sub(Variable(x), Variable(y)), e) =>
      (if (Lista.equal_lista[Str.char](x, y)) Value(Int.zero_int)
        else staticSub(staticEvalE(Variable(x), e), staticEvalE(Variable(y), e)))
    case (Sub(Constant(v), e2), e) =>
      staticSub(staticEvalE(Constant(v), e), staticEvalE(e2, e))
    case (Sub(Sum(v, va), e2), e) =>
      staticSub(staticEvalE(Sum(v, va), e), staticEvalE(e2, e))
    case (Sub(Sub(v, va), e2), e) =>
      staticSub(staticEvalE(Sub(v, va), e), staticEvalE(e2, e))
    case (Sub(e1, Constant(v)), e) =>
      staticSub(staticEvalE(e1, e), staticEvalE(Constant(v), e))
    case (Sub(e1, Sum(v, va)), e) =>
      staticSub(staticEvalE(e1, e), staticEvalE(Sum(v, va), e))
    case (Sub(e1, Sub(v, va)), e) =>
      staticSub(staticEvalE(e1, e), staticEvalE(Sub(v, va), e))
  }
  
  def staticEqual(e1: staticValue, e2: staticValue): option[Boolean] = (e1, e2)
    match {
    case (Value(x), Value(y)) => Somea[Boolean](Int.equal_int(x, y))
    case (Undefine(), e2) => Nonea[Boolean]()
    case (Either(v, va), e2) => Nonea[Boolean]()
    case (e1, Undefine()) => Nonea[Boolean]()
    case (e1, Either(v, va)) => Nonea[Boolean]()
  }
  
  def staticEvalC(x0: condition, t: List[(List[Str.char], staticValue)]):
        option[Boolean]
    =
    (x0, t) match {
    case (Eq(Variable(x), Variable(y)), t) =>
      (if (Lista.equal_lista[Str.char](x, y)) Somea[Boolean](true)
        else staticEqual(staticEvalE(Variable(x), t),
                          staticEvalE(Variable(y), t)))
    case (Eq(Constant(v), e2), t) =>
      staticEqual(staticEvalE(Constant(v), t), staticEvalE(e2, t))
    case (Eq(Sum(v, va), e2), t) =>
      staticEqual(staticEvalE(Sum(v, va), t), staticEvalE(e2, t))
    case (Eq(Sub(v, va), e2), t) =>
      staticEqual(staticEvalE(Sub(v, va), t), staticEvalE(e2, t))
    case (Eq(e1, Constant(v)), t) =>
      staticEqual(staticEvalE(e1, t), staticEvalE(Constant(v), t))
    case (Eq(e1, Sum(v, va)), t) =>
      staticEqual(staticEvalE(e1, t), staticEvalE(Sum(v, va), t))
    case (Eq(e1, Sub(v, va)), t) =>
      staticEqual(staticEvalE(e1, t), staticEvalE(Sub(v, va), t))
  }
  
  def cleanTable(x0: List[(List[Str.char], staticValue)]):
        List[(List[Str.char], staticValue)]
    =
    x0 match {
    case Nil => Nil
    case (x, e) :: xs => (x, Undefine()) :: cleanTable(xs)
  }
  
  def joinTables(x0: List[(List[Str.char], staticValue)],
                  ys: List[(List[Str.char], staticValue)]):
        List[(List[Str.char], staticValue)]
    =
    (x0, ys) match {
    case (Nil, ys) => cleanTable(ys)
    case ((x, Undefine()) :: xs, ys) => (x, Undefine()) :: joinTables(xs, ys)
    case ((x, Value(e)) :: xs, ys) =>
      (assoc[List[Str.char], staticValue](x, ys) match {
         case Nonea() => (x, Undefine()) :: joinTables(xs, ys)
         case Somea(Undefine()) => (x, Undefine()) :: joinTables(xs, ys)
         case Somea(Value(y)) =>
           (if (Int.equal_int(e, y)) (x, Value(e)) :: joinTables(xs, ys)
             else (x, Either(e, y)) :: joinTables(xs, ys))
         case Somea(Either(_, _)) => (x, Undefine()) :: joinTables(xs, ys)
       })
    case ((x, Either(a, b)) :: xs, ys) => (x, Undefine()) :: joinTables(xs, ys)
  }
  
  def getSection(t1: List[(List[Str.char], staticValue)],
                  t: List[(List[Str.char], staticValue)]):
        List[(List[Str.char], staticValue)]
    =
    {
      val sectionSize =
        Nat.minus_nat(Lista.size_list[(List[Str.char], staticValue)].apply(t1),
                       Lista.size_list[(List[Str.char], staticValue)].apply(t)):
          Nat.nat;
      Lista.take[(List[Str.char], staticValue)](sectionSize, t1)
    }
  
  def staticEvalS(xa0: statement,
                   x: (List[(List[Str.char], staticValue)], List[staticEvent])):
        (List[(List[Str.char], staticValue)], List[staticEvent])
    =
    (xa0, x) match {
    case (Skip, x) => x
    case (Aff(s, e), (t, outch)) => ((s, staticEvalE(e, t)) :: t, outch)
    case (If(c, s1, s2), (t, outch)) =>
      (staticEvalC(c, t) match {
         case Nonea() =>
           {
             val (t1, outch1) =
               staticEvalS(s1, (t, outch)):
                 ((List[(List[Str.char], staticValue)], List[staticEvent]))
             val (t2, outch2) =
               staticEvalS(s2, (t, outch)):
                 ((List[(List[Str.char], staticValue)], List[staticEvent]));
             (joinTables(getSection(t1, t), getSection(t2, t)) ++ t,
               outch1 ++ outch2)
           }
         case Somea(true) => staticEvalS(s1, (t, outch))
         case Somea(false) => staticEvalS(s2, (t, outch))
       })
    case (Seq(s1, s2), (t, outch)) =>
      {
        val (t2, outch2) =
          staticEvalS(s1, (t, outch)):
            ((List[(List[Str.char], staticValue)], List[staticEvent]));
        staticEvalS(s2, (t2, outch2))
      }
    case (Read(s), (t, outch)) => ((s, Undefine()) :: t, outch)
    case (Print(e), (t, outch)) => (t, SP(staticEvalE(e, t)) :: outch)
    case (Exec(e), (t, outch)) => {
                                    val res = staticEvalE(e, t): staticValue;
                                    (t, SX(res) :: outch)
                                  }
  }
  
  def staticBAD(x0: (List[(List[Str.char], staticValue)], List[staticEvent])):
        Boolean
    =
    x0 match {
    case (t, Nil) => false
    case (t, SX(Undefine()) :: outch) => true
    case (t, SX(Value(e)) :: outch) =>
      Int.equal_int(e, Int.zero_int) || staticBAD((t, outch))
    case (t, SX(Either(x, y)) :: outch) =>
      Int.equal_int(x, Int.zero_int) ||
        (Int.equal_int(y, Int.zero_int) || staticBAD((t, outch)))
    case (t, SP(e) :: outch) => staticBAD((t, outch))
  }
  
  def san4(statementa: statement): Boolean =
    ! (staticBAD(staticEvalS(statementa, (Nil, Nil))))
  
  def chosensan: statement => Boolean = ((a: statement) => san4(a))
  
  } /* object tp67 */